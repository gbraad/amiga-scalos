filescalos.docContent-Type: text/html


	<HTML><HEAD><TITLE>scalos.library</TITLE></HEAD><BODY BACKGROUND='http://scalos.striatum.org/gfx/backdrop.gif'>
	
	<FONT SIZE="5"><B>scalos.library</B></FONT><P><UL>
	<LI><A HREF="#1">--background</A></LI><LI><A HREF="#2">SCA_WBStart</A></LI><LI><A HREF="#3">SCA_SortNodes</A></LI><LI><A HREF="#4">SCA_NewAddAppIcon</A></LI><LI><A HREF="#5">SCA_RemoveAppObject</A></LI><LI><A HREF="#6">SCA_NewAddAppWindow</A></LI><LI><A HREF="#7">SCA_NewAddAppMenuItem</A></LI><LI><A HREF="#8">SCA_AllocStdNode</A></LI><LI><A HREF="#9">SCA_AllocNode</A></LI><LI><A HREF="#10">SCA_FreeNode</A></LI><LI><A HREF="#11">SCA_FreeAllNodes</A></LI><LI><A HREF="#12">SCA_MoveNode</A></LI><LI><A HREF="#13">SCA_SwapNodes</A></LI><LI><A HREF="#14">SCA_OpenIconWindow</A></LI><LI><A HREF="#15">SCA_LockWindowList</A></LI><LI><A HREF="#16">SCA_UnLockWindowList</A></LI><LI><A HREF="#17">SCA_AllocMessage</A></LI><LI><A HREF="#18">SCA_FreeMessage</A></LI><LI><A HREF="#19">SCA_InitDrag</A></LI><LI><A HREF="#20">SCA_EndDrag</A></LI><LI><A HREF="#21">SCA_AddBob</A></LI><LI><A HREF="#22">SCA_DrawDrag</A></LI><LI><A HREF="#23">SCA_UpdateIcon</A></LI><LI><A HREF="#24">SCA_MakeWBArgs</A></LI><LI><A HREF="#25">SCA_FreeWBArgs</A></LI><LI><A HREF="#26">SCA_ScreenTitleMsg</A></LI><LI><A HREF="#27">SCA_MakeScalosClass</A></LI><LI><A HREF="#28">SCA_FreeScalosClass</A></LI><LI><A HREF="#29">SCA_NewScalosObject</A></LI><LI><A HREF="#30">SCA_DisposeScalosObject</A></LI><LI><A HREF="#31">SCA_ScalosControlA</A></LI></UL><P><UL><UL><A NAME="1"><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	--background<BR><BR>    DESCRIPTION<BR>	This library is used as application interface for the Scalos<BR>	workbenchreplacement. It's only available if Scalos is running.<BR>	This means if the library-open fails Scalos isn't running.<BR><BR>	For information about NodeList see SCA_SortNodes() and Node see<BR>	SCA_AllocStdNode().<BR><BR></UL><HR><A NAME="#2"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_WBStart<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	succ SCA_WBStart (ArgArray, Taglist, NumArgs )<BR>	                   A0         A1       D0<BR><BR>	BOOL SCA_WBStart ( struct WBArg *ArgArray , <BR>		const struct TagItem *Taglist, ULONG NumArgs );<BR><BR>	BOOL SCA_WBStartTags( struct WBArg *ArgArray , ULONG NumArgs, <BR>		ULONG FirstTag, ... );<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	The first argument is used as filename for the to started program.<BR>	The Locks inside the ArgArray are automatically unlocked (use DupLock)<BR>	and the strings are copied.<BR>	The first element in ArgArray must contain the directory lock and <BR>	name of the icon to start.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	ArgArray - Standard Workbench Args<BR>	NumArgs - Number of Args in the ArgArray. This must be at least<BR>		  one.<BR>	Taglist - Pointer to a taglist.<BR><BR></UL><FONT SIZE="4"><B>    TAGS<BR></B></FONT><UL>	SCA_IconObject (Object *) - iconobject.library - IconObject to get<BR>	    information from it. No icon will be loaded.<BR><BR>	SCA_Priority (LONG) - priority for the newly started process<BR><BR>	SCA_Stacksize (ULONG) - stack size if no icon is available<BR><BR>	SCA_WaitTimeout (ULONG) - wait timeout in seconds<BR><BR>	SCA_Flags (ULONG) - Flags<BR>	    SCAF_WBStart_NoIcon - don't read an icon.<BR>	    SCAF_WBStart_Wait - wait until the program returns<BR>	    SCAF_WBStart_PathSearch - search through paths<BR>	    SCAF_WBStart_NoIconCheck - don't check icon type<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	succ - FALSE if the start fails. It only fails if not enough<BR>	       memory available or the WBL task couldn't be started.<BR>	       If the program couldn't be loaded it will return TRUE, because<BR>	       of it doesn't wait for the returncode of WBL task.<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	Locks will *NOT* be unlocked if this function fails!<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	diskobject.library<BR><BR></UL><HR><A NAME="#3"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_SortNodes<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_SortNodes (NodeList, CompareFunc, SortType)<BR>	                 A0          A1          D0<BR><BR>	void SCA_SortNodes ( struct ScalosNodeList *, struct Hook *, <BR>		ULONG SortType);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Sorts a list of MinNodes and uses the CompareFunc to find differences<BR>	between to nodes. NodeList is a pointer to a APTR which points to the<BR>	first node. The first node has as mln_succ a NULL and the last node <BR>	has as mln_pred a NULL. Only mln_succ, mln_pred and the address of the<BR>	of the first will changed. Nothing will be reallocated or freed.<BR><BR>	The CompareFunc will be called with a pointer to one node in A1 (Node0)<BR>	and a pointer to second node in A2 (Node1). You have to return a<BR>	specific value in D0:<BR>		  0	if Node0 = Node1<BR>		  1	if Node0 &lt; Node1<BR>		 -1	if Node0 &gt; Node1<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	NodeList - Pointer to an APTR which is a pointer to the first node<BR>	CompareFunc - Pointer to a Hook structure for the compare function<BR>	SortType -<BR>		SCA_SortType_Bubble	: enhanced BubbleSort<BR>		SCA_SortType_Selection	: SelectionSort<BR>		SCA_SortType_Insertion	: InsertionSort<BR>		SCA_SortType_Quick	: QuickSort<BR>		SCA_SortType_Best	: The nodes will be counted and then<BR>					  the best SortType will be used.<BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_AllocNode(), SCA_AllocStdNode(), SCA_FreeNode(), <BR>	SCA_FreeAllNodes(), SCA_MoveNode(), SCA_SwapNodes()<BR><BR></UL><HR><A NAME="#4"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_NewAddAppIcon<BR>	SCA_NewAddAppIconTags<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	AppObject = SCA_NewAddAppIcon (ID, UserData, IconObject, MessagePort, <BR>	   D0                          D0     D1         A0          A1 <BR>		Taglist)<BR>	          A2<BR><BR>	struct AppObject *SCA_NewAddAppIcon( ULONG ID, ULONG UserData, <BR>		struct IconObject *, struct MsgPort *, <BR>		const struct TagItem *Taglist);<BR><BR>	struct AppObject *SCA_NewAddAppIconTags( ULONG ID, ULONG UserData, <BR>		struct IconObject *, struct MsgPort *, <BR>		ULONG FirstTag, ...);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Adds an icon to the mainwindow of the Scalos-screen. See<BR>	workbench.library/AddAppIconA() for more information.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	ID, UserData - will be passed through the AppMessage<BR>	IconObject - diskobject.library - IconObject, IDTM_Layout should not<BR>	to be done.<BR>	MessagePort - a MsgPort where you will receive the AppMessage<BR>	Taglist - pointer to a taglist.<BR><BR></UL><FONT SIZE="4"><B>    TAGS<BR></B></FONT><UL>	Currently no tags are defined. With wb39.plugin, however, most of the<BR>	V44 workbench tags are supported.<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	AppObject - a private structure to be pass to SCA_RemoveAppObject() <BR>		    or NULL after failure<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_NewAddAppWindow(), SCA_NewAddAppMenuItem(), SCA_RemoveAppObject()<BR>	workbench.library/AddAppIconA()<BR><BR></UL><HR><A NAME="#5"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_NewAddAppWindow<BR>	SCA_NewAddAppWindowTags<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	AppObject = SCA_NewAddAppWindow (ID, UserData, Window, MessagePort, <BR>	   D0                            D0     D1       A0        A1<BR>		Taglist)<BR>	          A2<BR><BR>	struct AppObject *SCA_NewAddAppWindow( ULONG ID, ULONG UserData, <BR>		struct Window *, struct MsgPort *, <BR>		const struct TagItem *Taglist);<BR><BR>	struct AppObject *SCA_NewAddAppWindowTags( ULONG ID, ULONG UserData, <BR>		struct Window *, struct MsgPort *, ULONG FirstTag, ...);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Same as workbench.library/AddAppWindowA(). See there for further <BR>	information.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	ID, UserData - will be passed through the AppMessage<BR>	Window - Intuition Window<BR>	MessagePort - a MsgPort where you will receive the AppMessage<BR>	Taglist - pointer to a taglist.<BR><BR></UL><FONT SIZE="4"><B>    TAGS<BR></B></FONT><UL>	Currently no tags are defined.<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	AppObject - a private structure to be pass to SCA_RemoveAppObject <BR>		    or NULL on failure<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_NewAddAppIcon(), SCA_NewAddAppMenuItem(), SCA_RemoveAppObject()<BR>	workbench.library/AddAppWindowA()<BR><BR></UL><HR><A NAME="#6"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_NewAddAppMenuItem<BR>	SCA_NewAddAppMenuItemTags<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	AppObject = SCA_NewAddAppMenuItem (ID, UserData, Text, MessagePort, <BR>	   D0                              D0     D1      A0       A1<BR>		Taglist)<BR>	          A2<BR><BR>	struct AppObject *SCA_NewAddAppMenuItem ( ULONG ID, ULONG UserData, <BR>		CONST_STRPTR Text, struct MsgPort *, <BR>		const struct TagItem *Taglist);<BR><BR>	struct AppObject *SCA_NewAddAppMenuItemTags( ULONG ID, <BR>		ULONG UserData, CONST_STRPTR Text, struct MsgPort *, <BR>		ULONG FirstTag, ...);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Same as workbench.library/AddAppMenuItemA(). See there for further <BR>	information.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	ID, UserData - will be passed through the AppMessage<BR>	Text - a pointer to the menutext. Starting with V40, any menu<BR>	       text consisting entirely of '-', '_' or '~' characters will<BR>	       result in a separator bar to be added.<BR>	MessagePort - a MsgPort where you will receive the AppMessage<BR>	Taglist - pointer to a taglist.<BR><BR></UL><FONT SIZE="4"><B>    TAGS<BR></B></FONT><UL>	WBAPPMENUA_CommandKeyString (STRPTR) -- Command key to assign to<BR>	    this AppMenu. This must be a NUL-terminated string. If the<BR>	    string is empty, it will be ignored. Also, if the command key<BR>	    is already in use by a different menu item it will be ignored,<BR>	    too. In any case, only the first character of the string will<BR>	    be used (V40).<BR><BR>	    This tag defaults to NULL.<BR><BR>	WBAPPMENUA_GetKey (ULONG *) -- To add menus with sub menu items,<BR>	    you need to add a menu item first which the sub items will<BR>	    be added to later. In order to do this, add the item the sub items<BR>	    should be attached to and use the WBAPPMENUA_GetKey tag to<BR>	    obtain a key value. This key value is to be used later with the<BR>	    WBAPPMENUA_UseKey tag (V40.20).<BR><BR>	    This feature was introduced in Scalos 40.20, it<BR>	    does not work in any of the older Scalos releases.<BR><BR>	    This tag defaults to NULL.<BR><BR>	WBAPPMENUA_GetTitleKey (ULONG *) -- To add new entries to the Scalos<BR>	    menu strip you first need to create a new title to which the new<BR>	    menu items can be attached later. To do this, first create a new<BR>	    menu entry and use the WBAPPMENUA_GetTitleKey tag to obtain a key<BR>	    value. This key value is to be used later with the<BR>	    WBAPPMENUA_UseKey tag (V40.20).<BR><BR>	    This tag defaults to NULL.<BR><BR>	WBAPPMENUA_UseKey (ULONG) -- When adding a menu item with the<BR>	    WBAPPMENUA_UseKey tag, using a key value obtained by a previous<BR>	    invocation of AddAppMenuItemA(), the new menu item will be<BR>	    added as a sub item (V40.20).<BR><BR>	    If the key you provide was obtained via the WBAPPMENUA_GetTitleKey<BR>	    tag, then the item you add will be attached to the respective<BR>	    menu entry (V40.20).<BR><BR>	    This tag defaults to NULL.<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	AppObject - a private structure to be pass to SCA_RemoveAppObject or <BR>		    NULL on failure<BR><BR>	            Starting with V40, NULL will be returned if you attempt to<BR>	            add an AppMenu item to a menu which already contains 63<BR>	            menu items. Only a maximum of 15 sub items can be added <BR>	            to a menu item.<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_NewAddAppIcon(), SCA_NewAddAppWindow(), SCA_RemoveAppObject()<BR>	workbench.library/AddAppMenuItemA()<BR><BR></UL><HR><A NAME="#7"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_RemoveAppObject<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	succ = SCA_RemoveAppObject (AppObject)<BR>	 D0                        A0<BR><BR>	BOOL SCA_RemoveAppObject (struct AppObject *);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Removes an AppObject from Scalos. This could be an Icon, a Window or<BR>	a MenuItem.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	AppObject - result from SCA_NewAddAppIcon(), SCA_NewAddAppWindow() <BR>		    or SCA_NewAddAppMenuItem()<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	succ - currently it always returns TRUE<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_NewAddAppIcon(), SCA_NewAddAppWindow(), SCA_NewAddAppMenuItem()<BR><BR></UL><HR><A NAME="#8"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_AllocStdNode<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	Node = SCA_AllocStdNode (NodeList, NodeType)<BR>	 D0                        A0        D0<BR><BR>	struct MinNode *SCA_AllocStdNode (struct ScalosNodeList *, <BR>		ULONG NodeType);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Allocates a standard Scalos-node. It's the only compatible why to<BR>	allocate one of the standard nodes. NEVER allocate a node yourself and<BR>	pass it to Scalos! The scalos.library will use a memorypool for all<BR>	nodes to decrease the memoryfragmentation. The new node will be the<BR>	last in your NodeList and it is cleared public memory. Don't change<BR>	mln_succ and mln_pred yourself, use the node function instead.<BR>	See SCA_SortNodes() for information about the NodeList.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	NodeList - Pointer to an APTR which is a pointer to the first node<BR>	NodeType - see scalos.(h|i)<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	Node - Node at the end or the NodeList or NULL on failure.<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	Node *MUST* be freed with SCA_FreeNode() or SCA_FreeAllNodes()<BR>	This function preserves all registers except D0.<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_AllocNode(), SCA_FreeNode(), SCA_FreeAllNodes(), <BR>	SCA_MoveNode(), SCA_SortNodes(), SCA_SwapNodes()<BR><BR></UL><HR><A NAME="#9"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_AllocNode<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	Node = SCA_AllocNode (NodeList, Size)<BR>	 D0                      A0      D0<BR><BR>	struct MinNode *SCA_AllocNode (struct ScalosNodeList *, ULONG Size);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Allocates a node and inserts it at the end of the NodeList. Use this<BR>	function only for your own node-handling. Never allocate a standard<BR>	Scalos-node, use SCA_AllocStdNode() instead. Size is the number of <BR>	bytes that allocated after the the MinNode. This means the memsize <BR>	of node is size+MLN_SIZE.<BR>	See SCA_AllocStdNode() for further information.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	NodeList - Pointer to an APTR which is a pointer to the first node<BR>	Size - bytes after MLN_SIZE<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	Node - Node at the end or the NodeList or NULL on failure.<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	Node *MUST* be freed with SCA_FreeNode() or SCA_FreeAllNodes() !<BR>	This function preserves all registers except D0.<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_AllocStdNode(), SCA_FreeNode(), SCA_FreeAllNodes(), <BR>	SCA_MoveNode(), SCA_SortNodes(), SCA_SwapNodes()<BR><BR></UL><HR><A NAME="#10"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_FreeNode<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_FreeNode (NodeList, Node)<BR>	                 A0      A1<BR><BR>	void SCA_FreeNode (struct ScalosNodeList *, struct MinNode *);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Removes the Node out of the NodeList and Frees a node allocated with<BR>	SCA_AllocStdNode() or SCA_AllocNode().<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	NodeList - pointer to an APTR which is a pointer to the first node<BR>	Node - node to remove and free<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	Node *MUST* be part of NodeList!<BR>	This function preserves all registers.<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_AllocStdNode(), SCA_AllocNode(), SCA_FreeAllNodes(), <BR>	SCA_MoveNode(), SCA_SortNodes(), SCA_SwapNodes()<BR><BR></UL><HR><A NAME="#11"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_FreeAllNodes<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_FreeAllNodes (NodeList)<BR>	                    A0<BR><BR>	void SCA_FreeAllNodes (struct ScalosNodeList *);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Will free the whole list of nodes.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	NodeList - pointer to an APTR which is a pointer to the first node<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	This function preserves all registers.<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_AllocStdNode(), SCA_AllocNode(), SCA_FreeNode(), <BR>	SCA_MoveNode(), SCA_SortNodes(), SCA_SwapNodes()<BR><BR></UL><HR><A NAME="#12"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_MoveNode<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_MoveNode (SrcNodeList, DestNodeList, Node)<BR>	                  A0            A1        D0<BR><BR>	void SCA_MoveNode (struct ScalosNodeList *, struct ScalosNodeList *, <BR>		struct MinNode *);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Will remove the Node from SrcNodeList and will insert the Node at<BR>	the end of DestNodeList.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	SrcNodeList - pointer to an APTR which is a pointer to the first node<BR>	DestNodeList - pointer to an APTR which is a pointer to the first node<BR>	Node - MinNode<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	This function preserves all registers.<BR>	WARNING: Node *MUST* be member of SrcNodeList or very nasty <BR>		things will happen !!<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_AllocStdNode(), SCA_AllocNode(), SCA_FreeNode(), <BR>	SCA_FreeAllNodes(), SCA_SortNodes(), SCA_SwapNodes()<BR><BR></UL><HR><A NAME="#13"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_SwapNodes<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_SwapNodes ( SrcNode, DestNode, NodeList)<BR>	                  A0        A1        A2<BR><BR>	void SCA_SwapNodes (struct MinNode *, struct MinNode *, <BR>		struct ScalosNodeList *);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Swaps the positions of SrcNode and DestNode inside the NodeList.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	SrcNode - MinNode<BR>	DestNode - MinNode<BR>	NodeList - pointer to an APTR which is a pointer to the first node<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	SrcNode and DestNode *MUST* be part of NodeList!<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_AllocStdNode(), SCA_AllocNode(), SCA_FreeNode(), <BR>	SCA_FreeAllNodes(), SCA_MoveNode(), SCA_SortNodes()<BR><BR></UL><HR><A NAME="#14"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_OpenIconWindow<BR>	SCA_OpenIconWindowTags<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	succ SCA_OpenIconWindow ( TagList )<BR>	 D0                         A0<BR><BR>	BOOL SCA_OpenIconWindow ( const struct TagItem *TagList );<BR><BR>	BOOL SCA_OpenIconWindowTags(ULONG, ...);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	opens a windowtask filled with icons. All information will be given<BR>	as tags, see below.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	TagList - pointer to a taglist.<BR><BR></UL><FONT SIZE="4"><B>    TAGS<BR></B></FONT><UL>	    SCA_IconNode (struct ScaIconNode *) - fullfilled ScaIconNode<BR><BR>	    SCA_IconObject (Object *) - iconobject.library - iconobject<BR><BR>	    SCA_Path (CONST_STRPTR) - the path to open<BR><BR>	    SCA_MessagePort (struct MsgPort *) - Message port for reply <BR>		to startup message of new icon window process, or NULL.<BR><BR>	    SCA_WindowTitle (CONST_STRPTR) - windowtitle parsestring <BR>		( take a look at the prefsprogram for info)<BR><BR>	    SCA_WindowRect (struct IBox *) - rectangle with window <BR>		dimensions (see diskobject.library).<BR><BR>	    SCA_XOffset,SCA_YOffset (LONG) - virtual position<BR><BR>	    SCA_PatternNumber (ULONG) - background pattern number which is <BR>		configured in &quot;Scalos Pattern&quot; prefs<BR><BR>	    SCA_ShowAllFiles (ULONG) - TRUE or FALSE<BR><BR>	    SCA_ViewModes (ULONG) - view modes for the window<BR>		SCAV_ViewModes_Icon<BR>		SCAV_ViewModes_Name<BR>		SCAV_ViewModes_Size<BR>		SCAV_ViewModes_Date<BR>		SCAV_ViewModes_Time<BR>		SCAV_ViewModes_Comment<BR>		SCAV_ViewModes_Protection<BR>		SCAV_ViewModes_Owner<BR>		SCAV_ViewModes_Group<BR><BR>	    SCA_Flags (ULONG) - none available yet<BR><BR>	    SCA_Iconify (ULONG) - TRUE or FALSE for open iconified<BR><BR>	    SCA_NoStatusBar (ULONG) - TRUE or FALSE. Status bar will be <BR>		suppressed for this window if set to TRUE, even when status <BR>		bar is globally enabled.<BR><BR>	    SCA_NoActivateWindow (ULONG) - TRUE or FALSE. The new window <BR>		will not be activated if this tag is set to TRUE. <BR>		Defaults to FALSE.<BR><BR>	    SCA_WindowStruct (struct ScaWindowStruct **) - The pointer to the<BR>		ScaWindowStruct of the new generated Scalos window will be<BR>		returned. If the new Scalos window couldn't be opened, NULL<BR>		is returned.<BR><BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	succ - Success<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	One of SCA_IconNode, SCA_IconObject or SCA_Path must be given!<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL><BR></UL><HR><A NAME="#15"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_LockWindowList<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	Windowlist SCA_LockWindowList ( accessmode )<BR>	 D0                                D0<BR><BR>	struct ScaWindowList *SCA_LockWindowList ( LONG accessmode );<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Locks the windowlist and returns. This function is a main interface of<BR>	the Scalos-API. The messageport should be used to comunicate with a<BR>	windowtask. No window can be closed while the windowlist is locked.<BR>	For more information take a look at the ScalosAPI documentation.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	accessmode -<BR>		SCA_LockWindowList_Shared - locks the windowlist for a read-<BR>		                            only access<BR>		SCA_LockWindowList_Exclusiv - read and write access is know<BR>		                              available<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	windowlist - a struct ScaWindowList *<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	Normally you should not use the SCA_LockWindowList_Exclusiv. If you<BR>	lock the windowlist exclusiv you should NEVER use intuition calls!<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_UnLockWindowList()<BR><BR></UL><HR><A NAME="#16"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_UnLockWindowList<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_UnLockWindowList ()<BR><BR>	void SCA_UnLockWindowList ( void );<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Unlocks a with SCA_LockWindowList() locked windowlist.<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_LockWindowList()<BR><BR></UL><HR><A NAME="#17"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_AllocMessage<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	ScalosMessage SCA_AllocMessage( messagetype, additional_size)<BR>	   D0                               D0            D1<BR><BR>	struct ScalosMessage *SCA_AllocMessage ( ULONG messagetype, <BR>		UWORD additional_size );<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Allocates a message which could be sent to Scalos. It's the only<BR>	future-compatible way to do this. The scalos message signature and the<BR>	the message type will be set and the returned memory is cleared.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	messagetype - see ScalosAPI.doc<BR>	additional_size - number of bytes that will be added to the size of<BR>		          the message. Normally this should be 0.<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	ScalosMessage - a full-filled ScalosMessage of the selected type or NULL<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	Never try to free a message yourself, it will cause a memory trashing!<BR>	Scalos uses fast memorypool functions for its messages.<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_FreeMessage()<BR><BR></UL><HR><A NAME="#18"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_FreeMessage<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_FreeMessage( message )<BR>	                   A1<BR><BR>	void SCA_FreeMessage ( struct ScalosMessage *);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Frees a with SCA_AllocMessage() allocated message.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	message - struct ScalosMessage (returned from SCA_AllocMessage())<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_AllocMessage()<BR><BR></UL><HR><A NAME="#19"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_InitDrag<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	DragHandle SCA_InitDrag( Screen )<BR>	    D0                     A0<BR><BR>	struct DragHandle *SCA_InitDrag ( struct Screen *);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Inits special bobroutines. This routines are easy to use and<BR>	support 24bit bobs.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	Screen - the screen to use for the bobs or NULL for the default<BR>	         Scalos screen<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	DragHandle - a private structure to pass it to the other Drag functions<BR>		or NULL on failure.<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>    	SCA_DrawDrag(), SCA_EndDrag()<BR><BR></UL><HR><A NAME="#20"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_EndDrag<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_EndDrag( DragHandle )<BR>	                 A0<BR><BR>	void SCA_EndDrag ( struct DragHandle *);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Removes all bobs from screen and frees it, if nessesary it unlocks<BR>	the layers.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	DragHandle - result from SCA_InitDrag()<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>    	SCA_DrawDrag(), SCA_InitDrag()<BR><BR></UL><HR><A NAME="#21"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_AddBob<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	succ SCA_AddBob( DragHandle, Bitmap, Mask, Width, Height, <BR>	 D0                  A0        A1     A2     D0     D1<BR>		XOffset, YOffset )<BR>	           D2       D3<BR><BR>	BOOL SCA_AddBob ( struct DragHandle *, struct BitMap *, APTR Mask, <BR>		ULONG Width, ULONG Height, LONG XOffset, LONG YOffset );<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Addes a bitmap to the Boblist. Bitmap and Mask will be copied, it can <BR>	be freed after calling this function. Mask is a planar bitplane the <BR>	width divided by 8 and height. It must be in Chipram. X and Y offsets <BR>	are the offset from movepoint give in SCA_DrawDrag(). Normaly it's <BR>	the relative position to the mouse pointer.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	DragHandle - result from SCA_InitDrag()<BR>	Bitmap - a standard bitmap structure, any depth allowed<BR>	Mask - width/8 * height mask for the bitmap<BR>	Width - width in pixels<BR>	Height - height in pixels<BR>	XOffset - relative x-position to the move point<BR>	YOffset - relative y-position to the move point<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	succ - TRUE if anything went well, FALSE if some problem occured<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL><BR></UL><HR><A NAME="#22"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_DrawDrag<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_DrawDrag( DragHandle, X, Y, Flags )<BR>	                  A0      D0 D1   D2<BR><BR>	void SCA_DrawDrag ( struct DragHandle *, LONG X, LONG Y, ULONG Flags );<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Blits the bobs to the selected screen relative to the given position.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	DragHandle - result from SCA_InitDrag()<BR>	X - movepoint x direction<BR>	Y - movepoint y direction<BR>	Flags - <BR>	  SCAF_Drag_Transparent		- draw all bobs transparent, <BR>					  normally it's a raster (&quot;ghosted&quot;)<BR>	  SCAF_Drag_IndicateCopy	- draw all bobs plus <BR>					  &quot;copy&quot; indicator<BR>	  SCAF_Drag_NoDropHere		- draw all bobs plus <BR>				          &quot;no drop&quot; indicator<BR>	  SCAF_Drag_Hide		- hide bobs<BR>	  SCAF_Drag_IndicateMakeLink	- draw all bobs plus &quot;make link&quot; <BR>					  indicator<BR>	  SCAF_Drag_NoDrawDrag		- (internal use only)<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	Transparent drawing only works with CyberGfx installed and a <BR>	workbench screen of more than 256 colors (depth &gt; 8).<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>    	SCA_InitDrag(), SCA_EndDrag()<BR><BR></UL><HR><A NAME="#23"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_UpdateIcon<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_UpdateIcon( WindowType, SCA_UpdateIcon, UpdateIcon_Size )<BR>	                   D0           A0             D1<BR><BR>	void SCA_UpdateIcon ( UBYTE WindowType, struct ScaUpdateIcon_IW *,<BR>		 ULONG ui_SIZE );<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Refreshes an icon specified in SCA_UpdateIcon structure. The icon <BR>	will be loaded, removed or reloaded. The SCA_UpdateIcon struct <BR>	depends on the windowtype.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	WindowType - windowtype which should be updated<BR>	SCA_UpdateIcon - special information, depents on WindowType<BR>	UpdateIcon_Size - size of the SCA_UpdateIcon structure in bytes<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL><BR></UL><HR><A NAME="#24"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_MakeWBArgs<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	number = SCA_MakeWBArgs( Buffer, Iconnode, ArgsSize )<BR>	                           A0       A1        D0<BR><BR>	ULONG SCA_MakeWBArgs ( struct WBArg *Buffer, <BR>		struct ScaIconNode *Iconnode, ULONG ArgsSize);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Generates a WBArgs Array from all selected icons except the <BR>	given Iconode.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	Buffer   - Array of WBArg structures to save the Lock and <BR>		   Name pointers<BR>	Iconnode - an iconnode to exclude or NULL<BR>	ArgsSize - Number of WBArg's the buffer has room for<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	number - number of args generated<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_FreeWBArgs()<BR><BR></UL><HR><A NAME="#25"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_FreeWBArgs<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	number = SCA_FreeWBArgs( Buffer, Number, Flags )<BR>	                           A0      D0     D1<BR><BR>	void SCA_FreeWBArgs ( struct WBArg *Buffer, ULONG Number, <BR>		ULONG Flags);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Frees a WBArg array generated with SCA_MakeWBArgs.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	Buffer - Array with WBArg structures<BR>	Number - Number of WBArg's to free<BR>	Flags - <BR>		SCAB_FreeLocks - free the Locks<BR>		SCAB_FreeName - free the namefields<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_MakeWBArgs();<BR><BR></UL><HR><A NAME="#26"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_ScreenTitleMsg<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_ScreenTitleMsg( Format, Args )<BR>	                      A0     A1<BR><BR>	void SCA_ScreenTitleMsg ( CONST_STRPTR Format, APTR Args);<BR><BR>	void SCA_ScreenTitleMsgArgs( CONST_STRPTR Format, ...);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Show a message on ScreenTitle of all Scalos windows.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	Format - FormatString. All RawDoFmt() args are allowed.<BR>		special values :<BR>			NULL to recover the standard title. <BR>			~0   to recover the last non-standard title (message).<BR>	Args - the arguments for the formatstring<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	exec.library/RawDoFmt<BR><BR></UL><HR><A NAME="#27"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_MakeScalosClass<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	ScalosClass ( ClassName, SuperClassName, InstSize, DispFunc )<BR>	     D0           A0            A1          D0        A2<BR><BR>	struct ScalosClass *SCA_MakeScalosClass ( CONST_STRPTR ClassName, <BR>		CONST_STRPTR SuperClassName, UWORD InstSize, APTR DispFunc);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Addes a new BOOPSI Class to the internal classlist. ClassName may be <BR>	a new name or a classname that's already available. In this case the <BR>	class will replace or enhance a known class.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	ClassName - name of the new class or NULL for a private class<BR>	SuperClassName - name of the super class for the new class<BR>	InstSize - size of the instance variables<BR>	DispFunc - pointer to your Dispatcher function<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	ScalosClass - a ScalosClass structure or NULL if it fails<BR><BR></UL><FONT SIZE="4"><B>    NOTE<BR></B></FONT><UL>	If you like a add a subclass to your private class then use the <BR>	intuition class functions.<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_FreeScalosClass(), intuition.library/MakeClass<BR><BR></UL><HR><A NAME="#28"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_FreeScalosClass<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	scc SCA_FreeScalosClass( ScalosClass )<BR>	D0                          A0<BR><BR>	BOOL SCA_FreeScalosClass ( struct ScalosClass *);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Removes a ScalosClass from the internal classlist.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	ScalosClass - return value from SCA_MakeScalosClass()<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	succ - FALSE if the class couldn't be removed, else TRUE<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_MakeScalosClass(), FreeClass()<BR><BR></UL><HR><A NAME="#29"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_NewScalosObject<BR>	SCA_NewScalosObjectTags<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	Object SCA_NewScalosObject( ClassName, TagList )<BR>	  D0                            A0       A1<BR><BR>	Object *SCA_NewScalosObject ( CONST_STRPTR ClassName, <BR>		const struct TagItem *TagList);<BR><BR>	Object *SCA_NewScalosObjectTags( CONST_STRPTR ClassName, <BR>		ULONG FirstTag, ...);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Allocates and inits a new BOOPSI Object.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	ClassName - Scalos Classname<BR>	TagList - taglist (depends on the class)<BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>	Object - new BOOPSI Object or NULL<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_DisposeScalosObject(), NewObject()<BR><BR></UL><HR><A NAME="#30"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_DisposeScalosObject<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	SCA_DisposeScalosObject( Object )<BR>	                           A0<BR><BR>	void SCA_DisposeScalosObject (Object *);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	Disposes a object created with SCA_NewScalosObject().<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	Object - BOOPSI Object<BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	SCA_NewScalosObject(), DisposeObject()<BR></UL><HR><A NAME="#31"><BR><BR>    </LI><LI><B><FONT SIZE="4">NAME</FONT></B><UL><BR>	SCA_ScalosControlA -- Query or modify Scalos options (V40)<BR>	SCA_ScalosControl<BR><BR></UL><FONT SIZE="4"><B>    SYNOPSIS<BR></B></FONT><PRE>	ULONG SCA_ScalosControlA( Name, TagList )<BR>	  D0                        A0     A1<BR><BR>	ULONG SCA_ScalosControlA( CONST_STRPTR Name, <BR>		const struct TagItem *TagList);<BR><BR>	ULONG SCA_ScalosControl( CONST_STRPTR Name, ULONG FirstTag, ...);<BR><BR></PRE>&nbsp;<BR><FONT SIZE="4"><B>    FUNCTION<BR></B></FONT><UL>	With this function you can query or modify global Scalos parameters.<BR><BR></UL><FONT SIZE="4"><B>    INPUTS<BR></B></FONT><UL>	name -- Name of an object to query or modify.<BR><BR>	tags -- Additional options.<BR><BR></UL><FONT SIZE="4"><B>    TAGS<BR></B></FONT><UL>	SCALOSCTRLA_GetDefaultStackSize (ULONG *) -- Get the default stack<BR>	    size used by Scalos when launching Shell programs<BR>	    or programs without a valid stack size number.<BR><BR>	    The default stack size is 8192 bytes.<BR><BR>	SCALOSCTRLA_SetDefaultStackSize (ULONG) -- Set the default stack<BR>	    size used by Scalos when launching Shell programs<BR>	    or programs without a valid stack size number. You cannot<BR>	    set a stack size number smaller than 8192 bytes.<BR><BR>	SCALOSCTRLA_GetProgramList (struct List **) -- You can obtain a list<BR>	    of currently running Workbench programs; every entry of this<BR>	    list will have the complete path to the program and the<BR>	    program name in its Node-&gt;ln_Name. When you no longer need<BR>	    the list, don't forget to free it again using the tag<BR>	    WBCTRLA_FreeProgramList.<BR><BR>	SCALOSCTRLA_FreeProgramList (struct List *) -- With this tag you can<BR>	    free the list allocated by the SCALOSCTRLA_GetProgramList tag.<BR><BR>	SCALOSCTRLA_GetCloseWBDisabled (ULONG *) -- Get the current disable<BR>	    state for the intuition.library/CloseWorkBench() function. <BR>	    If TRUE, intuition.library/CloseWorkBench() always returns FALSE <BR>	    and Scalos will never close.<BR><BR>	SCALOSCTRLA_SetCloseWBDisabled (ULONG) -- Set the disable<BR>	    state for the intuition.library/CloseWorkBench() function.<BR>	    If TRUE, intuition.library/CloseWorkBench() always returns FALSE <BR>	    and Scalos will never close.<BR><BR>	SCALOSCTRLA_GetSplashEnable (ULONG *) -- Get the current disable<BR>	    state for the Scalos startup splash window. If TRUE, Scalos shows<BR>	    its splash window on startup.<BR><BR>	SCALOSCTRLA_SetSplashEnable (ULONG) -- Set the disable<BR>	    state for the Scalos startup splash window. If TRUE, Scalos shows<BR>	    its splash window on startup.<BR><BR>	SCALOSCTRLA_GetToolTipEnable (ULONG *) -- Get the current enable<BR>	    state for icon tool tips. If TRUE, icon tool tips will show up<BR>	    if the mouse pointer kept over an icon for some seconds.<BR><BR>	SCALOSCTRLA_SetToolTipEnable (ULONG) -- Set the enabled<BR>	    state for icon tool tips. If TRUE, icon tool tips will show up<BR>	    if the mouse pointer kept over an icon for some seconds.<BR><BR>	SCALOSCTRLA_GetToolTipDelay (ULONG *) -- Set the delay time until<BR>	    the icon tool tips pop up (in seconds).<BR><BR>	SCALOSCTRLA_SetToolTipDelay (ULONG) -- Set the delay time until<BR>	    the icon tool tips pop up (in seconds). You must specify a <BR>	    number between 1 and 599 seconds. Default delay time is 2 seconds.<BR><BR>	SCALOSCTRLA_GetOldDragIconMode (ULONG *) -- Enable old (workbench-<BR>	    like) icon dragging mode, i.e. all icons are visibly dragged.<BR>	    If turned OFF (=0), the new &quot;icon stack&quot; method is used.<BR>	    Default value is OFF (0).<BR><BR>	SCALOSCTRLA_SetOldDragIconMode (ULONG) -- Get the current icon <BR>	    dragging mode.<BR>	    0	New &quot;icon stack&quot; icon dragging method is used.<BR>	    1	Old (workbench-like) icon dragging mode, i.e. all icons <BR>		are visibly dragged<BR><BR>	SCALOSCTRLA_GetTypeRestartTime (ULONG *) -- Get the number of seconds<BR>	    that have to pass before typing the next character in a drawer<BR>	    window will restart with a new file name.<BR><BR>	SCALOSCTRLA_SetTypeRestartTime (ULONG) -- Set the number of seconds<BR>	    that have to pass before typing the next character in a drawer<BR>	    window will restart with a new file name. You must specify a<BR>	    number greater than 0. Default type restart time is 3 seconds.<BR><BR>	SCALOSCTRLA_GetEmulationMode (ULONG *) -- get a BOOL variable telling <BR>	    whether which mode Scalos is running in.<BR>	    TRUE	emulation mode<BR>	    FALSE	preview mode<BR><BR>	SCALOSCTRLA_GetStatusBarEnable (ULONG *) -- get a BOOL variable <BR>	    telling whether Scalos displays a status bar in every <BR>	    non-backdrop window.<BR><BR>	SCALOSCTRLA_SetStatusBarEnable (ULONG) -- Telling whether Scalos to <BR>	    display a status bar in every non-backdrop window (any non-zero <BR>	    value) or to display no status bars. Changes only apply to <BR>	    windows opened thereafter.<BR>	    TRUE	show status bar<BR>	    FALSE	don't show status bar<BR>	    NOTE: Changes only apply to windows opened thereafter.<BR><BR>	SCALOSCTRLA_GetStripedTextWindows (ULONG *) -- get a BOOL variable <BR>	    telling whether Scalos displays horizontally striped lines in <BR>	    text windows.<BR><BR>	SCALOSCTRLA_SetStripedTextWindows (ULONG) -- Tell whether Scalos to <BR>	    display  horizontally striped lines in text windows.<BR>	    TRUE	show stripes in text window<BR>	    FALSE	show standard background.<BR>	    NOTE: Changes only apply to windows opened thereafter.<BR><BR>	SCALOSCTRLA_GetDisplayDragCount (ULONG *) -- get a BOOL variable <BR>	    telling whether Scalos shows the number of dragged objects <BR>	    during Drag and Drop.<BR><BR>	SCALOSCTRLA_SetDisplayDragCount (ULONG) -- Tell whether Scalos to<BR>	    display the number of dragged objects during Drag and Drop.<BR>	    TRUE	show number of objects while dragging<BR>	    FALSE	don't show number of objects<BR><BR>	SCALOSCTRLA_GetWindowDropMarkMode (ULONG *) - get a ULONG variable<BR>	    telling when Scalos shows window drop marks during D&amp;D <BR>	    IDTV_WinDropMark_Never - never<BR>	    IDTV_WinDropMark_WindowedOnly - only on non-backdrop windows<BR>	    IDTV_WinDropMark_Always - always<BR><BR>	SCALOSCTRLA_SetWindowDropMarkMode (ULONG) - Set when Scalos will <BR>	    show window drop marks during D&amp;D <BR>	    IDTV_WinDropMark_Never - never<BR>	    IDTV_WinDropMark_WindowedOnly - only on non-backdrop windows<BR>	    IDTV_WinDropMark_Always - always<BR><BR>	SCALOSCTRLA_GetCopyHook (struct Hook **) - Obtain the current hook <BR>	    that will be invoked when Scalos starts copying files and <BR>	    data (V40).<BR><BR>	SCALOSCTRLA_SetCopyHook (struct Hook *) - Install a new hook that <BR>	    will be invoked when Scalos starts copying files and data (V40).<BR>	    The hook will be invoked exactly the same way as Workbench <BR>	    does with its WBCTRLA_SetCopyHook hook.<BR><BR>	SCALOSCTRLA_GetDeleteHook (struct Hook **) - Obtain the current hook <BR>	    that will be invoked when Scalos deletes files and drawers or <BR>	    empties the trashcan (V40).<BR><BR>	SCALOSCTRLA_SetDeleteHook (struct Hook *) - Install a new hook that <BR>	    will be invoked when Scalos deletes files and drawers or empties <BR>	    the trashcan (V40).<BR>	    The hook will be invoked exactly the same way as Workbench <BR>	    does with its WBCTRLA_SetDeleteHook hook.<BR>	    NOTE: this hook will take precedence over the <BR>	    	  installed &quot;Delete.module&quot;.<BR><BR>	SCALOSCTRLA_GetTextInputHook (struct Hook **) - Obtain the current <BR>	    hook that will be invoked when Scalos requests the user to enter <BR>	    text, i.e. when a file is to be renamed or a new drawer is to <BR>	    be created (V40).<BR><BR>	SCALOSCTRLA_SetTextInputHook (struct Hook *) - Install a new hook <BR>	    that will be invoked when Scalos requests the user to enter text, <BR>	    i.e. when a file is to be renamed or a new drawer is to <BR>	    be created (V40).<BR>	    The hook will be invoked exactly the same way as Workbench <BR>	    does with its WBCTRLA_SetTextInputHook hook.<BR>	    NOTE: this hook will take precedence over the installed <BR>		  &quot;NewDrawer.module&quot;, &quot;Execute.module&quot; and &quot;Rename.module&quot;.<BR><BR>	SCALOSCTRLA_AddCloseWBHook (struct Hook *) - Add a hook that will <BR>	    be invoked when Scalos is about to close (cleanup), and when <BR>	    Scalos has opened again (setup) (V40).<BR>	    The hook will be invoked exactly the same way as Workbench <BR>	    does with its WBCTRLA_AddSetupCleanupHook hook.<BR><BR>	SCALOSCTRLA_RemCloseWBHook (struct Hook *) - Remove a hook that has <BR>	    been installed with the SCALOSCTRLA_AddCloseWBHook tag (V40).<BR><BR>	SCALOSCTRLA_GetSupportedIconTypes (ULONG *) - Get bit mask <BR>            of all currently enabled icon types<BR>	    IDTV_IconType_NewIcon - display NewIcons<BR>	    IDTV_IconType_ColorIcon - display OS3.5 color icons<BR><BR>	SCALOSCTRLA_SetSupportedIconTypes (ULONG) - Select which <BR>	    icon types are enabled :<BR>	    IDTV_IconType_NewIcon - display NewIcons<BR>	    IDTV_IconType_ColorIcon - display OS3.5 color icons<BR><BR>	SCALOSCTRLA_GetMenuCommandList (struct List **) -- You can obtain a list<BR>	    of all supported menu command names. When you no longer need<BR>	    the list, don't forget to free it again using the tag<BR>	    WBCTRLA_FreeMenuCommandList.<BR><BR>	SCALOSCTRLA_FreeMenuCommandList (struct List *) -- With this tag you can<BR>	    free the list allocated by the SCALOSCTRLA_GetMenuCommandList tag.<BR><BR>	SCALOSCTRLA_GetCopyBuffSize (ULONG *) -- Query the size of the buffer <BR>	    used for moving and copying files.<BR><BR>	SCALOSCTRLA_SetCopyBuffSize (ULONG) -- Set the size of the buffer used <BR>	    for moving and copying files. The size can be changed <BR>	    between 4 KBytes and 4 MBytes (40.30).<BR><BR><BR><BR></UL><FONT SIZE="4"><B>    RESULT<BR></B></FONT><UL>        Returns the number of tags successfully processed. If the returned <BR>	value is less than the number of tags supplied, you can query the error<BR>	code using dos.library/IoErr().<BR><BR>    NOTES<BR>	This function may only be called by a Process.<BR><BR><BR></UL><FONT SIZE="4"><B>    SEE ALSO<BR></B></FONT><UL>	dos.library/IoErr<BR>	&lt;dos/dosextens.h&gt;<BR></UL><HR><A NAME="#32"><BR> 
	</LI></UL><P align="right">
	Generated on 12th April 2004 by ad2html.pl v0.87 by <A HREF="http://www.philprice.net" TARGET="_blank">Phil Price</A>
	</BODY></HTML>
	